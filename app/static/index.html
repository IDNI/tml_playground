<!DOCTYPE html>
<html>
	<head>
		<title>Tauchain's TML playground</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="Keywords" content="TML,Tau Meta-Language,Tau,Meta-Language,Language,Tauchain,IDNI,DATALOG,PDATALOG,P-DATALOG,Datalog with negation,Unstratified Datalog,PFP,finite ordered structures,PFP logic over finite ordered structures,logic programming,programming language,reasoning,inference engine,programming,playground,examples,exercises,demo" />
		<meta name="Description" content="Online playground for TML (Tau Meta Language) with examples." />
		<link rel="icon" href="data:,">
		<style>
			* {
				box-sizing: border-box;
			}
			body {
				font-family: Verdana, Geneva, sans-serif;
			}
			h1, h2 {
				margin: 0.2em 0;
			}
			textarea#logic_program {
				width: 100%;
				height: 18em;
				margin-bottom: 1em;
			}
			textarea#output {
				width: 100%;
				height: 20em;
			}
			@media only screen and (min-width: 768px) {
				textarea#logic_program {
					width: 720px;
					height: 20em;
				}
				textarea#output {
					width: 720px;
				}
				div#tests {
					width: 720px;
				}
			}
			.row::after {
				content: "";
				clear: both;
				display: table;
			}
			div.button,
			div.active-button {
				float: left;
				margin: 0.25em;
				border-width: 0 2px 3px 0;
				border-style: solid;
				border-color: #999999;
				background: #333333;
				color: #FFFFFF;
				padding: 0.1em 0.5em;
				padding-bottom: 0.2em;
				cursor: pointer;
			}
			.tests-label {
				margin: 0.25em;
				float: left;
			}
			.note {
				margin-top: 1em;
			}
			.xx-small,
			.note {
				font-size: xx-small;
			}
			.active-button {
				background: #AAAAAA!Important;
			}
			span.copyleft {
				display:inline-block;
				-moz-transform: scale(-1, 1);
				-webkit-transform: scale(-1, 1);
				-o-transform: scale(-1, 1);
				-ms-transform: scale(-1, 1);
				transform: scale(-1, 1);
			}
			.disabled-button {
				border-color: #DDDDDD!Important;
				background: #CCCCCC!Important;
				color: #AAAAAA!Important;
			}
			#status-info {
				display: none;
			}
		</style>
	</head>
	<body onload="test()">
		<h1>TML playground</h1>
		<div id="tests" class="row">
			<div class="button" id="t0" onclick="test(0)">intro</div>
			<div class="button" id="t1" onclick="test(1)">FACTS</div>
			<div class="button" id="t2" onclick="test(2)">RELATIONS</div>
			<div class="button" id="t3" onclick="test(3)">ARITY</div>
			<div class="button" id="t4" onclick="test(4)">RULES</div>
			<div class="button" id="t5" onclick="test(5)">VARIABLES</div>
			<div class="button" id="t6" onclick="test(6)">AND/OR</div>
			<div class="button" id="t7" onclick="test(7)">RECURSION</div>
			<div class="button" id="t8" onclick="test(8)">NEGATION</div>
			<div class="button" id="t9" onclick="test(9)">transitive
				closure</div>
			<div class="button" id="t10" onclick="test(10)">family</div>
		</div>
		<div>
			<h2>Logic program</h2>
			<textarea id="logic_program"></textarea>
		</div>
		<div class="row">
			<div id="run_button"  title="RUN"  onclick="run()"
				class="button">&#9654;</div>
			<div id="step_button" title="STEP" onclick="step()"
				class="button">&#9654;&#9646;</div>
			<div id="stop_button" title="STOP" onclick="stop()"
				class="button disabled-button" >&#9724;</div>
		</div>
		<div class="output">
			<h2>Output</h2>
			<textarea id="output"></textarea><br/>
			<input id="sort-result" type="checkbox" checked="true" />
			<span class="xx-small"> sort output</span>
			<input id="show-info"   type="checkbox" checked="true" />
			<span class="xx-small"> show info</span>
			<input id="autoscroll"  type="checkbox" />
			<span class="xx-small"> autoscroll</span>
		</div>
		<div id="status-info">
			RUNNING: <span id="running_status"></span>
			STEP: <span id="step_status"></span>
		</div>
		<div class="note">
			For more information about Tauchain and TML see
			<a href="https://github.com/idni/tau/">Tau's github</a>,
			<a href="http://idni.org/">http://idni.org/</a> or
			<a href="https://github.com/idni/tau#tml-tutorial-unfinished-draft"
				>TML Tutorial (Unfinished draft)</a>.
			<br />
			<a href="https://github.com/IDNI/tml_playground">Source</a>
			of the playground |
			<span class="copyleft" title="copyleft">&copy;</span>
			2019 Tomáš Klapka
			&lt;<a href="mailto:tomas@klapka.cz">tomas@klapka.cz</a>&gt;
			<br />
		</div>
		<!-- tml.min.js (29 kB)          -->
		<!-- tml.debug.min.js (32 kB)    -->
		<!-- tml.js (36 kB)              -->
		<!-- tml.debug.js (56 kB)        -->
		<script src="tml.debug.js"></script>
		<script type="text/javascript">
			const { lp } = require('tml');
			const s = {    // running state
				running: false,
				result: '' // output of the program
			}
			function start() {
				if (s.running) {
					console.log('Already running. Cannot start.');
					return;
				}
				// read logic program from the input textarea
				const source = document.getElementById('logic_program').value;
				// clear output and show running status
				document.getElementById('output').innerText = 'running...';
				// init state
				s.result = '';
				s.running = true;
				s.step = 0; // step counter
				s.d = 0;    // current db root
				s.s = [];   // previous steps' db roots
				s.p = new lp();
				try {
					s.raw = s.p.prog_read(lp.string_read_text(source));
					console.log("program dict: ", s.p.d);
					console.log('raw rules:', s.raw);
				} catch (err) { // parse error
					console.log('Parse error:', err);
					s.result = `Parse error: ${err}`;
				}
				show_status();
			}
			function stop() {
				s.running = false;
				show_status();
				output_result(s.p.toString());
			}
			function run() { step(0); }
			// Do N steps. default 1. 0 = infinity (ie. run until a fixed point)
			function step(n = 1) {
				if (!s.running) {
					start();
				}
				for (let i = 0; n === 0 || i < n; i++) {
					s.d = s.p.db;  // get current db root
					s.s.push(s.d); // store current db root into previous steps
					console.log(`step: ${++s.step} nodes: ${s.p.pdbs.length}` +
						` + ${s.p.pprog.length}\n`);
					try {
						s.p.step(); // do pfp step
					} catch (err) {
						console.log('PFP error', err);
						s.result = `PFP error: ${err}`;
						return false;
					}
					// FP if db root resulted already from a previous step
					if (s.s.includes(s.p.db)) {
						if (s.d === s.p.db) {
							s.result = s.p.toString(); // sat
						} else {
							s.result = 'unsat';
						}
						s.d = 0;
						s.running = false;
						output_result(s.result);
						break;
					}
					output_result(s.p.toString());
				}
				show_status();
			}
			function output_result(result) {
				// sort output if sort-result checked
				if (document.getElementById('sort-result').checked) {
					result = result.split(`\n`).sort().join(`\n`);
				}
				result = result.trim();
				// add info if show-info checked
				if (document.getElementById('show-info').checked) {
					result = `# STEP: ${s.step} ` +
						`STATUS: ${s.running?'RUNNING':'STOPPED'}\n\n` + result;
				}
				// update output textarea with new output
				const output = document.getElementById('output');
				output.innerHTML = result;
				// autoscroll if checked
				if (document.getElementById('autoscroll').checked) {
					output.scrollTop = output.scrollHeight
				}
			}
			function show_status() {
				const rs = document.getElementById('running_status');
				const ss = document.getElementById('step_status');
				const sb = document.getElementById('stop_button');
				rs.innerText = s.running ? 'true' : 'false';
				ss.innerText = s.running ? s.step : 'n/a';
				sb.classList = "button" + (s.running ? "" : " disabled-button");
			}
			show_status();
			////////////////////
			// test programs
			//
			let t = 1; // current test program chosen
			function test(n) {
				n = n || 0;
				// read current program from logic program textarea
				const current = document.getElementById('logic_program').value;
				let confirmed = true;
				// ask for confirmation if current program running
				if (s.running) {
					confirmed = confirmed
						&& confirm('Program is running. Do you want to stop?')
					stop();
				}
				// if there is a custom program, ask for confirmation before discarding
				if (current && current.length > 0
				&& !test_programs.includes(current)) {
					confirmed = confirmed
						&& confirm('Do you want to discard your program?');
				}
				if (confirmed) {
					// populate the logic program
					const logic_program = document
						.getElementById('logic_program');
					logic_program.value = test_programs[n];
					logic_program.scrollTop = 0; // scroll top
					// deactivate old button and activate the new one
					document.getElementById('t'+t).className = 'button';
					t = n;
					document.getElementById('t'+t).className = 'active-button';
				}
			}
			const test_programs = [
// intro
`# Enter your TML logic program here and
# press RUN to execute.
#
# Any text following the '#' character is
# a comment and is ignored by TML.
#
# Logic programs consist of logic clauses.
# This program has no logic clause.
#
# Clauses can be either FACTS or RULES and
# they are terminated by the '.' character
# like sentences in English.`,
// FACTS
`# Facts define RELATIONS between entities.
# Fact clauses are considered to be true.

father Tom Amy.   # Tom is a father of Amy.
canFly bird.      # Bird can fly.
edge 6 3.         # Exists an edge from 6 to 3.
night.            # It's night.
1 2.              # Exists a pair 1-2.
direct London NY. # London has a direct to NY.
3 9 12.           # Exists a triple 3-9-12.
beginsWithJ Joe.  # Joe begins with J.

# Output is padded by '*' character when
# different ARITIES are used.`,
// RELATIONS
`# Every FACT begins with a predicate,
# which is also the name of a relation.
#
# We can think of:
#     relations as tables,
#     facts as rows and
#     entities as columns.
#
# Set of relations is called a model, or
# relational structure.
#                    _____________
                  # |_beginsWithJ_|
beginsWithJ Jane. # |    Jane     |
beginsWithJ John. # |    John     |
beginsWithJ Jack. # |____Jack_____|
                  #  _____________
                  # |___uncle_____|
uncle Jim Joe.    # |  Jim | Joe  |
uncle Joe Jill.   # |  Joe | Jill |
uncle Joe Jack.   # |__Joe_|_Jack_|

employee John Doe sales.
employee Jane Doe support.
#  ______________________
# |______employee________|
# | John | Doe | sales   |
# |_Jane_|_Doe_|_support_|

# FACTS (rows) in a relation (table) are
# unordered. It means it doesn't matter which
# fact comes first.
# Entities (columns) are unnamed and ordered.
# It's a difference from common relational
# databases where columns are named.
#
# Number of columns is also called ARITY.`,
// ARITY
`# Every clause has its arity. It's a dimension
# of the domain in the corresponding Cartesian
# product.
# Basically it's a number of RELATION's entities
# (columns). It can be written as 'n-ary' or
# latin/greek name is used.

# Arity (latin/greek):

# 0-ary (nullary/niladic)
rain.
night.

# 1-ary (unary/monadic)
happy Sue.
barks Max.

# 2-ary (binary/dyadic)
mother Jane Jack.
employee John Doe.

# 3-ary (ternary/triadic)
married Tom Jane 2004.
employee Jane Doe support.

# ...
# 6-ary (senary)
a 1 2 3 4 5 6.

# 2-ary or more are also
# called multiary/polyadic

# Output of TML is padded by '*' character
# up to the highest known arity.`,
// RULES
`# Rules allow creation/inferring of new facts.
# Every rule has a head and a body separated by
# ':-' symbol. Head is on the left side and body
# is on the right side.
# Rules are also called Horn Clauses.
# They work the way that head is true if body is
# true.
# You can imagine rules like facts (in head)
# with conditions (in body).

# TML takes all the known facts and tries to
# match them into bodies of all the known rules.
# When a fact matches a body of a rule it infers
# new fact from the head of the rule.

rain.                   # rain.
wet :- rain.            # wet if rain.
freezing :- bellowZero. # freezing if bellow 0.

# Here TML infers it's wet because it knows it
# rains.
# See there is 'rain' and 'wet' in the output.
# There is no 'freezing' because there is no
# 'bellowZero'.

1 2.        # 1-2 exists.
1 4.        # 1-4 exists.
3 1 :- 1 3. # 3-1 exists if 1-3 exists.
2 1 :- 1 2. # 2-1 exists if 1-2 exists.

# Here TML infers 2 1 because there exist 1 2.
# You should see 1 2, 1 4 and 2 1 in the output.
# There is no 3 1 because there is no 1 3.

employee Suzi female.
salutation Suzi Madam :- employee Suzi female.

# If employee Suzi is female, Suzi's salutation
# is Madam.
# TML correctly infers that Suzi's salutation is
# Madam because employee Suzi is female.

# Rules become more powerful when used with
# VARIABLES.`,
// VARIABLES
`# Variables are used for substitution of
# multiple possible entities in rules.
# If a variable is substituted by an entity
# in a body it is substituted by the same entity
# in body's head.
# Variables begin with '?' character.

bird Charlie.
bird Coco.
cat Bella.

canFly ?something :- bird ?something.
# If something is a bird, it can fly.
# TML infers that Charlie and Coco can fly.

beeps ?some :- bird ?some.
# If there is some bird, it beeps.
# TML infers that Charlie and Coco beeps.

meows ?some :- cat ?some.
# If there is some cat, it meows.
# TML infers that Bella meows.


employee Suzi female.
employee John male.
employee Jane female.

salutation ?Person Madam :-
    employee ?Person female.
# salutation for any employee female is Madam.
# TML infers that Suzi's and Jane's salutation
# is Madam.

salutation ?Person Sir :-
    employee ?Person male.
# salutation for any employee male is Sir
# TML infers that John's salutation is Sir.


parent ?x ?y :- father ?x ?y.
parent ?x ?y :- mother ?x ?y.
father Coco Charlie.
mother Suzi John.

# TML infers that Coco is Charlie's parent.
# and that Suzi is John's parent.

# Just for fun, let's say, John is a bird:
bird John.

# TML infers that John beeps and he can fly.`,
// AND/OR
`# When you need multiple conditions in a body
# separate them by a comma. You can read comma
# as 'and':

boy ?x :- child ?x, male ?x.
# ?x is a boy if ?x is both child and male.

girl ?x :- child ?x, female ?x.
# ?x is a girl if ?x is both child and female.

# When you need multiple bodies for the same
# head, you can have multiple rules with the
# same head:

human ?x :- child ?x.
human ?x :- adult ?x.
# ?x is a human if ?x is child or adult.

adult Amy.
child John.
child Jack.
child Jane.
child Suzi.
male John.
male Jack.
female Amy.
female Jane.
female Suzi.

# TML infers: Jack and John are boys.
# Jane and Suzi are girls.
# And Amy, Jack, Jane, John and Suzi are
# humans.`,
// RECURSION
`# Recursion is used to traverse through
# all the entities in a relation.
# It's a logic programs' alternative to loops.

# We can have a relation of parents.
parent Fred Sue.
parent Jack Fred.
parent Amy Fred.
parent Grace Amy.
parent Tom Amy.

# Let's say we want to know all the ancestor
# relations of all the known entities.

# We need to create 2 rules so TML knows,
# what ancestor means. Ancestor is a parent
# or a parent of an ancestor.

# 'parent of a child is an ancestor of the
# child':
ancestor ?anc ?child :-
    parent ?anc ?child.

# 'parent of a child, who is an ancestor of
# its descendant, is an ancestor of the
# descendant':
ancestor ?anc ?desc :-
    parent ?anc ?child, ancestor ?child ?desc.

# Notice how ancestor relation is used in both
# head and body. This is causing the recursion.`,
// NEGATION
`# Negation does not work properly yet.
#
# For negation is used a '~' character.
# You can read it as 'not'.

bird Coco.
bird Charlie.
wounded Charlie.

canFly ?X :- bird ?X, ~wounded ?X.
# ?X can fly if ?X is bird and is not wounded.
# or simply: Not wounded bird can fly.

# Coco and Charlie are birds but Charlie is
# wounded. The only fact TML can infere here
# is that Coco can fly.`,
// TRANSITIVE CLOSURE
`# Transitive closure of a directed graph is
# simply another directed graph representing
# paths in the original graph.

# Let's have a directed graph represented by
# 'e' relation:
e 1 2.
e 2 3.
e 3 4.
e 4 5.
e 5 1.
e 8 9.

tc ?x ?y :- e ?x ?y.
# Edge from ?x to ?y is a path from ?x to ?y.

tc ?x ?y :- tc ?x ?z, e ?z ?y.
# If there is a path from ?x to ?z and there
# is an edge from ?z to ?y there is path from
# ?x to ?y

# TML infers all the possible paths in the
# 'e' graph into 'tc' graph.`,
// family
`father Tom Amy.
father Jack Fred.
father Tony CarolII.
father Fred CarolIII.

mother Grace Amy.
mother Amy Fred.
mother CarolI CarolII.
mother CarolII CarolIII.

parent ?X ?Y :- father ?X ?Y.
parent ?X ?Y :- mother ?X ?Y.
ancestor ?X ?Y :- parent ?X ?Y.
ancestor ?X ?Y :- parent ?X ?Z, ancestor ?Z ?Y.

# This example is taken
# from Datalog Educational System
# http://des.sourceforge.net/`
			];
		</script>
	</body>
</html>
