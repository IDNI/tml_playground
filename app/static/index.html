<!DOCTYPE html>
<html>
	<head>
		<title>Tauchain's TML playground</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="Keywords" content="TML,Tau Meta-Language,Tau,Meta-Language,Language,Tauchain,IDNI,DATALOG,PDATALOG,P-DATALOG,Datalog with negation,Unstratified Datalog,PFP,finite ordered structures,PFP logic over finite ordered structures,logic programming,programming language,reasoning,inference engine,programming,playground,examples,exercises,demo" />
		<meta name="Description" content="Online playground for TML (Tau Meta Language) with examples." />
		<link rel="icon" href="data:,">
		<link rel="stylesheet" type="text/css" href="style.css" />
	</head>
	<body onload="init_playground()">
		<h1>TML playground</h1>
		<div class="row">
			<div id="link_button" title="get link to this program" onclick="link()"
				class="button">&#128279;</div>
			<div id="run_button"  title="run program"  onclick="run()"
				class="button">&#9654;</div>
			<div id="step_button" title="do a step" onclick="step()"
				class="button">&#9654;&#9646;</div>
			<div id="stop_button" title="stop running" onclick="stop()"
				class="button disabled-button" >&#9724;</div>
			<div class="bar-select">
				<select id="tests-select" onchange="test(document.getElementById('tests-select').value)">
					<option value="0">intro</option>
					<option value="1">FACTS</option>
					<option value="2">RELATIONS</option>
					<option value="3">ARITY</option>
					<option value="4">RULES</option>
					<option value="5">VARIABLES</option>
					<option value="6">AND/OR</option>
					<option value="7">RECURSION</option>
					<option value="8">NEGATION</option>
					<option value="9">transitive closure</option>
					<option value="10">family</option>
				</select>
			</div>
		</div>
		<div class="row">
			<div>
				<input id="live_coding" type="checkbox" checked="true" />
				<span class="xx-small"> live coding</span>
				<input id="sort-result" type="checkbox" checked="true" />
				<span class="xx-small"> sort output</span>
				<input id="show-info"   type="checkbox" checked="true" />
				<span class="xx-small"> show info</span>
				<input id="autoscroll"  type="checkbox" />
				<span class="xx-small"> autoscroll</span>
			</div>
			<div class="panel">
				<textarea id="logic_program" oninput="on_program_change()""></textarea>
			</div>
			<div class="panel">
				<div id="running_program"></div>
			</div>
			<div class="panel">
				<div id="dict_vars" class="dict"></div>
				<div id="dict_syms" class="dict"></div>
			</div>
			</div>
		<div class="output">
			<h2>Output</h2>
			<textarea id="output"></textarea><br/>
		</div>
		<div id="status-info">
			RUNNING: <span id="running_status"></span>
			STEP: <span id="step_status"></span>
		</div>
		<div class="note">
			For more information about Tauchain and TML see
			<a href="https://github.com/idni/tau/">Tau's github</a>,
			<a href="http://idni.org/">http://idni.org/</a> or
			<a href="https://github.com/idni/tau#tml-tutorial-unfinished-draft"
				>TML Tutorial (Unfinished draft)</a>.
			<br />
			<a href="https://github.com/IDNI/tml_playground">Source</a>
			of the playground |
			<span class="copyleft" title="copyleft">&copy;</span>
			2019 Tomáš Klapka
			&lt;<a href="mailto:tomas@klapka.cz">tomas@klapka.cz</a>&gt;
			<br />
		</div>
		<!--------------------------------->
		<!-- HTML ends here              -->
		<!--------------------------------->
		<!-- javascript starts here      -->
		<!--------------------------------->
		<!-- tml.min.js       (19 kB)    -->
		<!-- tml.debug.min.js (32 kB)    -->
		<!-- tml.js           (36 kB)    -->
		<!-- tml.debug.js     (56 kB)    -->
		<script src="tml.min.js"></script>
		<script type="text/javascript">
			const { lp } = require('tml');
			const s = {    // running state
				running: false,
				result: '' // output of the program
			}
			function start() {
				if (s.running) {
					console.log('Already running. Cannot start.');
					return;
				}
				// read logic program from the input textarea
				let source = document.getElementById('logic_program').value;
				// clear output and show running status
				document.getElementById('output').innerText = 'running...';
				// init state
				s.result = '';
				s.running = true;
				s.step = 0; // step counter
				s.d = 0;    // current db root
				s.s = [];   // previous steps' db roots
				s.raw = []; // empty raw program
				s.p = new lp();
				try {
					 // strip comments and multiple lines
					source = lp.string_read_text(source);
					// document.getElementById('running_program')
					// 	.innerHTML = source.replace(/\n+/gm, `<br/>`);
					s.raw = s.p.prog_read(source);
					update_running_program();
					// console.log("program dict: ", s.p.d);
					// console.log('raw rules:', s.raw);
				} catch (err) { // parse error
					console.log('Parse error:', err);
					s.result = `Parse error: ${err}`;
				}
				show_status();
			}
			function restart() {
				s.running = false;
				start();
			}
			function stop() {
				s.running = false;
				show_status();
				output_result(s.p.toString());
			}
			function rerun() { s.running = false; run(); }
			function run() { step(0); }
			// Do N steps. default 1. 0 = infinity (ie. run until a fixed point)
			function step(n = 1) {
				if (!s.running) {
					start();
				}
				for (let i = 0; n === 0 || i < n; i++) {
					s.d = s.p.db;  // get current db root
					s.s.push(s.d); // store current db root into previous steps
					console.log(`step: ${++s.step} nodes: ${s.p.pdbs.length}` +
						` + ${s.p.pprog.length}\n`);
					try {
						s.p.step(); // do pfp step
					} catch (err) {
						console.log('Runtime error', err);
						s.result = `Runtime error: ${err}`;
						return false;
					}
					// FP if db root resulted already from a previous step
					if (s.s.includes(s.p.db)) {
						if (s.d === s.p.db) {
							s.result = s.p.toString(); // sat
						} else {
							s.result = 'unsat';
						}
						s.d = 0;
						s.running = false;
						output_result(s.result);
						break;
					}
					output_result(s.p.toString());
				}
				show_status();
			}
			function output_result(result) {
				// sort output if sort-result checked
				if (document.getElementById('sort-result').checked) {
					result = result.split(`\n`).sort().join(`\n`);
				}
				result = result.trim();
				// add info if show-info checked
				if (document.getElementById('show-info').checked) {
					result = `# STEP: ${s.step} ` +
						`STATUS: ${s.running?'RUNNING':'STOPPED'}\n\n` + result;
				}
				// update output textarea with new output
				const output = document.getElementById('output');
				output.innerHTML = result;
				// autoscroll if checked
				if (document.getElementById('autoscroll').checked) {
					output.scrollTop = output.scrollHeight
				}
			}
			function update_dictionary() {
				const table = (a, neg = false) => {
					let res = `<table>\n    <tr><th colspan="2">${neg?'variables':'symbols'}</th></tr>\n`;
					for (let i = 1; i < a.length; i++) {
						res += `    <tr><td>${neg?'-':''}${i}</td><td>${a[i]}</td></tr>\n`
					}
					return res + `</table>\n`;
				}
				document.getElementById('dict_syms').innerHTML = table(s.p.d.syms);
				document.getElementById('dict_vars').innerHTML = table(s.p.d.vars, true);
			}
			function update_running_program() {
				const arg_toString = a => {
					const str = a < 0
						? s.p.d.vars[-a]
						: a > 0
							? s.p.d.get(a)
							: false;
					return str ? `<span title="${str}"><sub class="varid">${a}</sub>${str}</span>` : str;
				}
				const term_toString = t => {
					const res = `${t[0]<0 ? '~' : ''}${t.slice(1).map(arg_toString).filter(str=>str!==false).join(' ')}`;
					return res;
				}
				const rule_toString = r => {
					let res = term_toString(r[r.length-1]); // head or fact
					const body_len = r.length-1;
					if (body_len) {	// rule body
						res += ' :- ';
						for (let i = 0; i < body_len; i++) {
							//console.log('res before adding body term, ', i, res);
							res += term_toString(r[i]) + (i+1 < body_len ? ', ' : '');
							//console.log('res after adding body term, ', i, res);
						}
					}
					res += `.<br/>\n`;
					return res;
				}
				document.getElementById('running_program')
					.innerHTML = s.raw.map(rule_toString).join('');
				update_dictionary();
			}
			function show_status() {
				const rs = document.getElementById('running_status');
				const ss = document.getElementById('step_status');
				const sb = document.getElementById('stop_button');
				rs.innerText = s.running ? 'true' : 'false';
				ss.innerText = s.running ? s.step : 'n/a';
				sb.classList = "button" + (s.running ? "" : " disabled-button");
			}
			function link() {
				const href = window.location.href;
				const prog = document.getElementById('logic_program').value;
				href.search = 'prog=' + encodeURIComponent(prog);
				const link = prompt(`Open URL in new window?\nOr copy to clipboard and cancel.`, href);
				if (link != null) {
					window.open(linke, '_blank');
				}
			}
			// Returns a function, that, as long as it continues to be invoked, will not
			// be triggered. The function will be called after it stops being called for
			// N milliseconds. If `immediate` is passed, trigger the function on the
			// leading edge, instead of the trailing.
			// https://davidwalsh.name/javascript-debounce-function
			function debounce(fn, wait, immediate) {
				let t;
				return () => {
					const a = arguments;
					const l = () => {
						t = null;
						if (!immediate) fn.apply(this, a);
					};
					var its_time = immediate && !t;
					clearTimeout(t);
					t = setTimeout(l, wait);
					if (its_time) fn.apply(this, a);
				};
			};
			const debounce_live_coding = debounce(rerun, 200);
			function on_program_change() {
				if (document.getElementById('live_coding').checked) {
					debounce_live_coding();
				}
			}
			function init_playground() {
				const prog = new URLSearchParams(window.location.search).get('prog');
				if (prog && prog.length > 0)  { // load prog from URL
					document.getElementById('logic_program').value = prog;
				} else { // or load intro if not in URL
					test(9);
				}
				show_status();
			}
			////////////////////
			// test programs
			//
			let t = 1; // current test program chosen
			function test(n) {
				n = n || 0;
				// read current program from logic program textarea
				const current = document.getElementById('logic_program').value;
				let confirmed = true;
				// ask for confirmation if current program running
				// if (s.running) {
				// 	confirmed = confirmed
				// 		&& confirm('Program is running. Do you want to stop?')
				// 	stop();
				// }
				// if there is a custom program, ask for confirmation before discarding
				if (current && current.length > 0
				&& !test_programs.includes(current)) {
					confirmed = confirmed
						&& confirm('Do you want to discard your program?');
				}
				if (confirmed) {
					// populate the logic program
					const logic_program = document
						.getElementById('logic_program');
					logic_program.value = test_programs[n];
					logic_program.scrollTop = 0; // scroll top
					// deactivate old button and activate the new one
					// document.getElementById('t'+t).className = 'button';
					t = n;
					// document.getElementById('t'+t).className = 'active-button';
					if (document.getElementById('live_coding').checked) {
						rerun();
					} else {
						restart();
					}
				}
				// update (or rollback) selection
				document.getElementById('tests-select').value = t;
			}
			const test_programs = [
// intro
`# Enter your TML logic program here and
# press RUN to execute.
#
# Any text following the '#' character is
# a comment and is ignored by TML.
#
# Logic programs consist of logic clauses.
# This program has no logic clause.
#
# Clauses can be either FACTS or RULES and
# they are terminated by the '.' character
# like sentences in English.`,
// FACTS
`# Facts define RELATIONS between entities.
# Fact clauses are considered to be true.

father Tom Amy.   # Tom is a father of Amy.
canFly bird.      # Bird can fly.
edge 6 3.         # Exists an edge from 6 to 3.
night.            # It's night.
1 2.              # Exists a pair 1-2.
direct London NY. # London has a direct to NY.
3 9 12.           # Exists a triple 3-9-12.
beginsWithJ Joe.  # Joe begins with J.

# Output is padded by '*' character when
# different ARITIES are used.`,
// RELATIONS
`# Every FACT begins with a predicate,
# which is also the name of a relation.
#
# We can think of:
#     relations as tables,
#     facts as rows and
#     entities as columns.
#
# Set of relations is called a model, or
# relational structure.
#                    _____________
                  # |_beginsWithJ_|
beginsWithJ Jane. # |    Jane     |
beginsWithJ John. # |    John     |
beginsWithJ Jack. # |____Jack_____|
                  #  _____________
                  # |___uncle_____|
uncle Jim Joe.    # |  Jim | Joe  |
uncle Joe Jill.   # |  Joe | Jill |
uncle Joe Jack.   # |__Joe_|_Jack_|

employee John Doe sales.
employee Jane Doe support.
#  ______________________
# |______employee________|
# | John | Doe | sales   |
# |_Jane_|_Doe_|_support_|

# FACTS (rows) in a relation (table) are
# unordered. It means it doesn't matter which
# fact comes first.
# Entities (columns) are unnamed and ordered.
# It's a difference from common relational
# databases where columns are named.
#
# Number of columns is also called ARITY.`,
// ARITY
`# Every clause has its arity. It's a dimension
# of the domain in the corresponding Cartesian
# product.
# Basically it's a number of RELATION's entities
# (columns). It can be written as 'n-ary' or
# latin/greek name is used.

# Arity (latin/greek):

# 0-ary (nullary/niladic)
rain.
night.

# 1-ary (unary/monadic)
happy Sue.
barks Max.

# 2-ary (binary/dyadic)
mother Jane Jack.
employee John Doe.

# 3-ary (ternary/triadic)
married Tom Jane 2004.
employee Jane Doe support.

# ...
# 6-ary (senary)
a 1 2 3 4 5 6.

# 2-ary or more are also
# called multiary/polyadic

# Output of TML is padded by '*' character
# up to the highest known arity.`,
// RULES
`# Rules allow creation/inferring of new facts.
# Every rule has a head and a body separated by
# ':-' symbol. Head is on the left side and body
# is on the right side.
# Rules are also called Horn Clauses.
# They work the way that head is true if body is
# true.
# You can imagine rules like facts (in head)
# with conditions (in body).

# TML takes all the known facts and tries to
# match them into bodies of all the known rules.
# When a fact matches a body of a rule it infers
# new fact from the head of the rule.

rain.                   # rain.
wet :- rain.            # wet if rain.
freezing :- bellowZero. # freezing if bellow 0.

# Here TML infers it's wet because it knows it
# rains.
# See there is 'rain' and 'wet' in the output.
# There is no 'freezing' because there is no
# 'bellowZero'.

1 2.        # 1-2 exists.
1 4.        # 1-4 exists.
3 1 :- 1 3. # 3-1 exists if 1-3 exists.
2 1 :- 1 2. # 2-1 exists if 1-2 exists.

# Here TML infers 2 1 because there exist 1 2.
# You should see 1 2, 1 4 and 2 1 in the output.
# There is no 3 1 because there is no 1 3.

employee Suzi female.
salutation Suzi Madam :- employee Suzi female.

# If employee Suzi is female, Suzi's salutation
# is Madam.
# TML correctly infers that Suzi's salutation is
# Madam because employee Suzi is female.

# Rules become more powerful when used with
# VARIABLES.`,
// VARIABLES
`# Variables are used for substitution of
# multiple possible entities in rules.
# If a variable is substituted by an entity
# in a body it is substituted by the same entity
# in body's head.
# Variables begin with '?' character.

bird Charlie.
bird Coco.
cat Bella.

canFly ?something :- bird ?something.
# If something is a bird, it can fly.
# TML infers that Charlie and Coco can fly.

beeps ?some :- bird ?some.
# If there is some bird, it beeps.
# TML infers that Charlie and Coco beeps.

meows ?some :- cat ?some.
# If there is some cat, it meows.
# TML infers that Bella meows.


employee Suzi female.
employee John male.
employee Jane female.

salutation ?Person Madam :-
    employee ?Person female.
# salutation for any employee female is Madam.
# TML infers that Suzi's and Jane's salutation
# is Madam.

salutation ?Person Sir :-
    employee ?Person male.
# salutation for any employee male is Sir
# TML infers that John's salutation is Sir.


parent ?x ?y :- father ?x ?y.
parent ?x ?y :- mother ?x ?y.
father Coco Charlie.
mother Suzi John.

# TML infers that Coco is Charlie's parent.
# and that Suzi is John's parent.

# Just for fun, let's say, John is a bird:
bird John.

# TML infers that John beeps and he can fly.`,
// AND/OR
`# When you need multiple conditions in a body
# separate them by a comma. You can read comma
# as 'and':

boy ?x :- child ?x, male ?x.
# ?x is a boy if ?x is both child and male.

girl ?x :- child ?x, female ?x.
# ?x is a girl if ?x is both child and female.

# When you need multiple bodies for the same
# head, you can have multiple rules with the
# same head:

human ?x :- child ?x.
human ?x :- adult ?x.
# ?x is a human if ?x is child or adult.

adult Amy.
child John.
child Jack.
child Jane.
child Suzi.
male John.
male Jack.
female Amy.
female Jane.
female Suzi.

# TML infers: Jack and John are boys.
# Jane and Suzi are girls.
# And Amy, Jack, Jane, John and Suzi are
# humans.`,
// RECURSION
`# Recursion is used to traverse through
# all the entities in a relation.
# It's a logic programs' alternative to loops.

# We can have a relation of parents.
parent Fred Sue.
parent Jack Fred.
parent Amy Fred.
parent Grace Amy.
parent Tom Amy.

# Let's say we want to know all the ancestor
# relations of all the known entities.

# We need to create 2 rules so TML knows,
# what ancestor means. Ancestor is a parent
# or a parent of an ancestor.

# 'parent of a child is an ancestor of the
# child':
ancestor ?anc ?child :-
    parent ?anc ?child.

# 'parent of a child, who is an ancestor of
# its descendant, is an ancestor of the
# descendant':
ancestor ?anc ?desc :-
    parent ?anc ?child, ancestor ?child ?desc.

# Notice how ancestor relation is used in both
# head and body. This is causing the recursion.`,
// NEGATION
`# Negation does not work properly yet.
#
# For negation is used a '~' character.
# You can read it as 'not'.

bird Coco.
bird Charlie.
wounded Charlie.

canFly ?X :- bird ?X, ~wounded ?X.
# ?X can fly if ?X is bird and is not wounded.
# or simply: Not wounded bird can fly.

# Coco and Charlie are birds but Charlie is
# wounded. The only fact TML can infere here
# is that Coco can fly.`,
// TRANSITIVE CLOSURE
`# Transitive closure of a directed graph is
# simply another directed graph representing
# paths in the original graph.

# Let's have a directed graph represented by
# 'e' relation:
e 1 2.
e 2 3.
e 3 4.
e 4 5.
e 5 1.
e 8 9.

tc ?x ?y :- e ?x ?y.
# Edge from ?x to ?y is a path from ?x to ?y.

tc ?x ?y :- tc ?x ?z, e ?z ?y.
# If there is a path from ?x to ?z and there
# is an edge from ?z to ?y there is path from
# ?x to ?y

# TML infers all the possible paths in the
# 'e' graph into 'tc' graph.`,
// family
`father Tom Amy.
father Jack Fred.
father Tony CarolII.
father Fred CarolIII.

mother Grace Amy.
mother Amy Fred.
mother CarolI CarolII.
mother CarolII CarolIII.

parent ?X ?Y :- father ?X ?Y.
parent ?X ?Y :- mother ?X ?Y.
ancestor ?X ?Y :- parent ?X ?Y.
ancestor ?X ?Y :- parent ?X ?Z, ancestor ?Z ?Y.

# This example is taken
# from Datalog Educational System
# http://des.sourceforge.net/`
			];
		</script>
	</body>
</html>
